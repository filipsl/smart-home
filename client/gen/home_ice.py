# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.3
#
# <auto-generated>
#
# Generated from file `home.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module Home
_M_Home = Ice.openModule('Home')
__name__ = 'Home'

if 'PowerState' not in _M_Home.__dict__:
    _M_Home.PowerState = Ice.createTempClass()
    class PowerState(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    PowerState.ON = PowerState("ON", 0)
    PowerState.OFF = PowerState("OFF", 1)
    PowerState._enumerators = { 0:PowerState.ON, 1:PowerState.OFF }

    _M_Home._t_PowerState = IcePy.defineEnum('::Home::PowerState', PowerState, (), PowerState._enumerators)

    _M_Home.PowerState = PowerState
    del PowerState

if 'TempUnit' not in _M_Home.__dict__:
    _M_Home.TempUnit = Ice.createTempClass()
    class TempUnit(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    TempUnit.CELSIUS = TempUnit("CELSIUS", 0)
    TempUnit.FAHRENHEIT = TempUnit("FAHRENHEIT", 1)
    TempUnit._enumerators = { 0:TempUnit.CELSIUS, 1:TempUnit.FAHRENHEIT }

    _M_Home._t_TempUnit = IcePy.defineEnum('::Home::TempUnit', TempUnit, (), TempUnit._enumerators)

    _M_Home.TempUnit = TempUnit
    del TempUnit

if 'Temperature' not in _M_Home.__dict__:
    _M_Home.Temperature = Ice.createTempClass()
    class Temperature(object):
        def __init__(self, value=0.0, unit=_M_Home.TempUnit.CELSIUS):
            self.value = value
            self.unit = unit

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_Home.Temperature):
                return NotImplemented
            else:
                if self.value != other.value:
                    return False
                if self.unit != other.unit:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_Home._t_Temperature)

        __repr__ = __str__

    _M_Home._t_Temperature = IcePy.defineStruct('::Home::Temperature', Temperature, (), (
        ('value', (), IcePy._t_double),
        ('unit', (), _M_Home._t_TempUnit)
    ))

    _M_Home.Temperature = Temperature
    del Temperature

if 'TimeOfDay' not in _M_Home.__dict__:
    _M_Home.TimeOfDay = Ice.createTempClass()
    class TimeOfDay(object):
        def __init__(self, hour=0, minute=0):
            self.hour = hour
            self.minute = minute

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.hour)
            _h = 5 * _h + Ice.getHash(self.minute)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Home.TimeOfDay):
                return NotImplemented
            else:
                if self.hour is None or other.hour is None:
                    if self.hour != other.hour:
                        return (-1 if self.hour is None else 1)
                else:
                    if self.hour < other.hour:
                        return -1
                    elif self.hour > other.hour:
                        return 1
                if self.minute is None or other.minute is None:
                    if self.minute != other.minute:
                        return (-1 if self.minute is None else 1)
                else:
                    if self.minute < other.minute:
                        return -1
                    elif self.minute > other.minute:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Home._t_TimeOfDay)

        __repr__ = __str__

    _M_Home._t_TimeOfDay = IcePy.defineStruct('::Home::TimeOfDay', TimeOfDay, (), (
        ('hour', (), IcePy._t_short),
        ('minute', (), IcePy._t_short)
    ))

    _M_Home.TimeOfDay = TimeOfDay
    del TimeOfDay

if 'AutoStartParams' not in _M_Home.__dict__:
    _M_Home.AutoStartParams = Ice.createTempClass()
    class AutoStartParams(object):
        def __init__(self, timeOfDay=Ice._struct_marker, durationMins=0):
            if timeOfDay is Ice._struct_marker:
                self.timeOfDay = _M_Home.TimeOfDay()
            else:
                self.timeOfDay = timeOfDay
            self.durationMins = durationMins

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.timeOfDay)
            _h = 5 * _h + Ice.getHash(self.durationMins)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Home.AutoStartParams):
                return NotImplemented
            else:
                if self.timeOfDay is None or other.timeOfDay is None:
                    if self.timeOfDay != other.timeOfDay:
                        return (-1 if self.timeOfDay is None else 1)
                else:
                    if self.timeOfDay < other.timeOfDay:
                        return -1
                    elif self.timeOfDay > other.timeOfDay:
                        return 1
                if self.durationMins is None or other.durationMins is None:
                    if self.durationMins != other.durationMins:
                        return (-1 if self.durationMins is None else 1)
                else:
                    if self.durationMins < other.durationMins:
                        return -1
                    elif self.durationMins > other.durationMins:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Home._t_AutoStartParams)

        __repr__ = __str__

    _M_Home._t_AutoStartParams = IcePy.defineStruct('::Home::AutoStartParams', AutoStartParams, (), (
        ('timeOfDay', (), _M_Home._t_TimeOfDay),
        ('durationMins', (), IcePy._t_int)
    ))

    _M_Home.AutoStartParams = AutoStartParams
    del AutoStartParams

if 'ErrorBase' not in _M_Home.__dict__:
    _M_Home.ErrorBase = Ice.createTempClass()
    class ErrorBase(Ice.UserException):
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Home::ErrorBase'

    _M_Home._t_ErrorBase = IcePy.defineException('::Home::ErrorBase', ErrorBase, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    ErrorBase._ice_type = _M_Home._t_ErrorBase

    _M_Home.ErrorBase = ErrorBase
    del ErrorBase

if 'SwitchedOffError' not in _M_Home.__dict__:
    _M_Home.SwitchedOffError = Ice.createTempClass()
    class SwitchedOffError(_M_Home.ErrorBase):
        def __init__(self, reason=''):
            _M_Home.ErrorBase.__init__(self, reason)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Home::SwitchedOffError'

    _M_Home._t_SwitchedOffError = IcePy.defineException('::Home::SwitchedOffError', SwitchedOffError, (), False, _M_Home._t_ErrorBase, ())
    SwitchedOffError._ice_type = _M_Home._t_SwitchedOffError

    _M_Home.SwitchedOffError = SwitchedOffError
    del SwitchedOffError

if 'NotDefinedError' not in _M_Home.__dict__:
    _M_Home.NotDefinedError = Ice.createTempClass()
    class NotDefinedError(_M_Home.ErrorBase):
        def __init__(self, reason=''):
            _M_Home.ErrorBase.__init__(self, reason)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Home::NotDefinedError'

    _M_Home._t_NotDefinedError = IcePy.defineException('::Home::NotDefinedError', NotDefinedError, (), False, _M_Home._t_ErrorBase, ())
    NotDefinedError._ice_type = _M_Home._t_NotDefinedError

    _M_Home.NotDefinedError = NotDefinedError
    del NotDefinedError

if 'TemperatureRangeError' not in _M_Home.__dict__:
    _M_Home.TemperatureRangeError = Ice.createTempClass()
    class TemperatureRangeError(_M_Home.ErrorBase):
        def __init__(self, reason='', minTemp=0.0, maxTemp=0.0, unit=_M_Home.TempUnit.CELSIUS):
            _M_Home.ErrorBase.__init__(self, reason)
            self.minTemp = minTemp
            self.maxTemp = maxTemp
            self.unit = unit

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Home::TemperatureRangeError'

    _M_Home._t_TemperatureRangeError = IcePy.defineException('::Home::TemperatureRangeError', TemperatureRangeError, (), False, _M_Home._t_ErrorBase, (
        ('minTemp', (), IcePy._t_double, False, 0),
        ('maxTemp', (), IcePy._t_double, False, 0),
        ('unit', (), _M_Home._t_TempUnit, False, 0)
    ))
    TemperatureRangeError._ice_type = _M_Home._t_TemperatureRangeError

    _M_Home.TemperatureRangeError = TemperatureRangeError
    del TemperatureRangeError

if 'TimeRangeError' not in _M_Home.__dict__:
    _M_Home.TimeRangeError = Ice.createTempClass()
    class TimeRangeError(_M_Home.ErrorBase):
        def __init__(self, reason='', minHour=0, maxHour=0, minMinute=0, maxMinute=0):
            _M_Home.ErrorBase.__init__(self, reason)
            self.minHour = minHour
            self.maxHour = maxHour
            self.minMinute = minMinute
            self.maxMinute = maxMinute

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Home::TimeRangeError'

    _M_Home._t_TimeRangeError = IcePy.defineException('::Home::TimeRangeError', TimeRangeError, (), False, _M_Home._t_ErrorBase, (
        ('minHour', (), IcePy._t_short, False, 0),
        ('maxHour', (), IcePy._t_short, False, 0),
        ('minMinute', (), IcePy._t_short, False, 0),
        ('maxMinute', (), IcePy._t_short, False, 0)
    ))
    TimeRangeError._ice_type = _M_Home._t_TimeRangeError

    _M_Home.TimeRangeError = TimeRangeError
    del TimeRangeError

if 'DurationError' not in _M_Home.__dict__:
    _M_Home.DurationError = Ice.createTempClass()
    class DurationError(_M_Home.ErrorBase):
        def __init__(self, reason='', minDurationMins=0, maxDurationMins=0):
            _M_Home.ErrorBase.__init__(self, reason)
            self.minDurationMins = minDurationMins
            self.maxDurationMins = maxDurationMins

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Home::DurationError'

    _M_Home._t_DurationError = IcePy.defineException('::Home::DurationError', DurationError, (), False, _M_Home._t_ErrorBase, (
        ('minDurationMins', (), IcePy._t_int, False, 0),
        ('maxDurationMins', (), IcePy._t_int, False, 0)
    ))
    DurationError._ice_type = _M_Home._t_DurationError

    _M_Home.DurationError = DurationError
    del DurationError

_M_Home._t_Device = IcePy.defineValue('::Home::Device', Ice.Value, -1, (), False, True, None, ())

if 'DevicePrx' not in _M_Home.__dict__:
    _M_Home.DevicePrx = Ice.createTempClass()
    class DevicePrx(Ice.ObjectPrx):

        def getPowerState(self, context=None):
            return _M_Home.Device._op_getPowerState.invoke(self, ((), context))

        def getPowerStateAsync(self, context=None):
            return _M_Home.Device._op_getPowerState.invokeAsync(self, ((), context))

        def begin_getPowerState(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Device._op_getPowerState.begin(self, ((), _response, _ex, _sent, context))

        def end_getPowerState(self, _r):
            return _M_Home.Device._op_getPowerState.end(self, _r)

        def setPowerState(self, powerState, context=None):
            return _M_Home.Device._op_setPowerState.invoke(self, ((powerState, ), context))

        def setPowerStateAsync(self, powerState, context=None):
            return _M_Home.Device._op_setPowerState.invokeAsync(self, ((powerState, ), context))

        def begin_setPowerState(self, powerState, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Device._op_setPowerState.begin(self, ((powerState, ), _response, _ex, _sent, context))

        def end_setPowerState(self, _r):
            return _M_Home.Device._op_setPowerState.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Home.DevicePrx.ice_checkedCast(proxy, '::Home::Device', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Home.DevicePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Home::Device'
    _M_Home._t_DevicePrx = IcePy.defineProxy('::Home::Device', DevicePrx)

    _M_Home.DevicePrx = DevicePrx
    del DevicePrx

    _M_Home.Device = Ice.createTempClass()
    class Device(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Home::Device', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Home::Device'

        @staticmethod
        def ice_staticId():
            return '::Home::Device'

        def getPowerState(self, current=None):
            raise NotImplementedError("servant method 'getPowerState' not implemented")

        def setPowerState(self, powerState, current=None):
            raise NotImplementedError("servant method 'setPowerState' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Home._t_DeviceDisp)

        __repr__ = __str__

    _M_Home._t_DeviceDisp = IcePy.defineClass('::Home::Device', Device, (), None, ())
    Device._ice_type = _M_Home._t_DeviceDisp

    Device._op_getPowerState = IcePy.Operation('getPowerState', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_Home._t_PowerState, False, 0), ())
    Device._op_setPowerState = IcePy.Operation('setPowerState', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Home._t_PowerState, False, 0),), (), None, ())

    _M_Home.Device = Device
    del Device

# Start of module Home.AC
_M_Home.AC = Ice.openModule('Home.AC')
__name__ = 'Home.AC'

if 'PollutionLevel' not in _M_Home.AC.__dict__:
    _M_Home.AC.PollutionLevel = Ice.createTempClass()
    class PollutionLevel(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    PollutionLevel.LOW = PollutionLevel("LOW", 0)
    PollutionLevel.MEDIUM = PollutionLevel("MEDIUM", 1)
    PollutionLevel.HIGH = PollutionLevel("HIGH", 2)
    PollutionLevel._enumerators = { 0:PollutionLevel.LOW, 1:PollutionLevel.MEDIUM, 2:PollutionLevel.HIGH }

    _M_Home.AC._t_PollutionLevel = IcePy.defineEnum('::Home::AC::PollutionLevel', PollutionLevel, (), PollutionLevel._enumerators)

    _M_Home.AC.PollutionLevel = PollutionLevel
    del PollutionLevel

_M_Home.AC._t_AirConditioner = IcePy.defineValue('::Home::AC::AirConditioner', Ice.Value, -1, (), False, True, None, ())

if 'AirConditionerPrx' not in _M_Home.AC.__dict__:
    _M_Home.AC.AirConditionerPrx = Ice.createTempClass()
    class AirConditionerPrx(_M_Home.DevicePrx):

        def setTargetTemperature(self, temp, context=None):
            return _M_Home.AC.AirConditioner._op_setTargetTemperature.invoke(self, ((temp, ), context))

        def setTargetTemperatureAsync(self, temp, context=None):
            return _M_Home.AC.AirConditioner._op_setTargetTemperature.invokeAsync(self, ((temp, ), context))

        def begin_setTargetTemperature(self, temp, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.AC.AirConditioner._op_setTargetTemperature.begin(self, ((temp, ), _response, _ex, _sent, context))

        def end_setTargetTemperature(self, _r):
            return _M_Home.AC.AirConditioner._op_setTargetTemperature.end(self, _r)

        def getTargetTemperature(self, context=None):
            return _M_Home.AC.AirConditioner._op_getTargetTemperature.invoke(self, ((), context))

        def getTargetTemperatureAsync(self, context=None):
            return _M_Home.AC.AirConditioner._op_getTargetTemperature.invokeAsync(self, ((), context))

        def begin_getTargetTemperature(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.AC.AirConditioner._op_getTargetTemperature.begin(self, ((), _response, _ex, _sent, context))

        def end_getTargetTemperature(self, _r):
            return _M_Home.AC.AirConditioner._op_getTargetTemperature.end(self, _r)

        def setAutoStart(self, autoStartParams, context=None):
            return _M_Home.AC.AirConditioner._op_setAutoStart.invoke(self, ((autoStartParams, ), context))

        def setAutoStartAsync(self, autoStartParams, context=None):
            return _M_Home.AC.AirConditioner._op_setAutoStart.invokeAsync(self, ((autoStartParams, ), context))

        def begin_setAutoStart(self, autoStartParams, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.AC.AirConditioner._op_setAutoStart.begin(self, ((autoStartParams, ), _response, _ex, _sent, context))

        def end_setAutoStart(self, _r):
            return _M_Home.AC.AirConditioner._op_setAutoStart.end(self, _r)

        def getAutoStartParams(self, context=None):
            return _M_Home.AC.AirConditioner._op_getAutoStartParams.invoke(self, ((), context))

        def getAutoStartParamsAsync(self, context=None):
            return _M_Home.AC.AirConditioner._op_getAutoStartParams.invokeAsync(self, ((), context))

        def begin_getAutoStartParams(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.AC.AirConditioner._op_getAutoStartParams.begin(self, ((), _response, _ex, _sent, context))

        def end_getAutoStartParams(self, _r):
            return _M_Home.AC.AirConditioner._op_getAutoStartParams.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Home.AC.AirConditionerPrx.ice_checkedCast(proxy, '::Home::AC::AirConditioner', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Home.AC.AirConditionerPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Home::AC::AirConditioner'
    _M_Home.AC._t_AirConditionerPrx = IcePy.defineProxy('::Home::AC::AirConditioner', AirConditionerPrx)

    _M_Home.AC.AirConditionerPrx = AirConditionerPrx
    del AirConditionerPrx

    _M_Home.AC.AirConditioner = Ice.createTempClass()
    class AirConditioner(_M_Home.Device):

        def ice_ids(self, current=None):
            return ('::Home::AC::AirConditioner', '::Home::Device', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Home::AC::AirConditioner'

        @staticmethod
        def ice_staticId():
            return '::Home::AC::AirConditioner'

        def setTargetTemperature(self, temp, current=None):
            raise NotImplementedError("servant method 'setTargetTemperature' not implemented")

        def getTargetTemperature(self, current=None):
            raise NotImplementedError("servant method 'getTargetTemperature' not implemented")

        def setAutoStart(self, autoStartParams, current=None):
            raise NotImplementedError("servant method 'setAutoStart' not implemented")

        def getAutoStartParams(self, current=None):
            raise NotImplementedError("servant method 'getAutoStartParams' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Home.AC._t_AirConditionerDisp)

        __repr__ = __str__

    _M_Home.AC._t_AirConditionerDisp = IcePy.defineClass('::Home::AC::AirConditioner', AirConditioner, (), None, (_M_Home._t_DeviceDisp,))
    AirConditioner._ice_type = _M_Home.AC._t_AirConditionerDisp

    AirConditioner._op_setTargetTemperature = IcePy.Operation('setTargetTemperature', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Home._t_Temperature, False, 0),), (), None, (_M_Home._t_TemperatureRangeError,))
    AirConditioner._op_getTargetTemperature = IcePy.Operation('getTargetTemperature', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_Home._t_Temperature, False, 0), ())
    AirConditioner._op_setAutoStart = IcePy.Operation('setAutoStart', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Home._t_AutoStartParams, False, 0),), (), None, (_M_Home._t_TimeRangeError, _M_Home._t_DurationError))
    AirConditioner._op_getAutoStartParams = IcePy.Operation('getAutoStartParams', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_Home._t_AutoStartParams, False, 0), (_M_Home._t_NotDefinedError,))

    _M_Home.AC.AirConditioner = AirConditioner
    del AirConditioner

_M_Home.AC._t_AirConditionerPurifier = IcePy.defineValue('::Home::AC::AirConditionerPurifier', Ice.Value, -1, (), False, True, None, ())

if 'AirConditionerPurifierPrx' not in _M_Home.AC.__dict__:
    _M_Home.AC.AirConditionerPurifierPrx = Ice.createTempClass()
    class AirConditionerPurifierPrx(_M_Home.AC.AirConditionerPrx):

        def setPollutionTreshLevel(self, pollutionLevel, context=None):
            return _M_Home.AC.AirConditionerPurifier._op_setPollutionTreshLevel.invoke(self, ((pollutionLevel, ), context))

        def setPollutionTreshLevelAsync(self, pollutionLevel, context=None):
            return _M_Home.AC.AirConditionerPurifier._op_setPollutionTreshLevel.invokeAsync(self, ((pollutionLevel, ), context))

        def begin_setPollutionTreshLevel(self, pollutionLevel, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.AC.AirConditionerPurifier._op_setPollutionTreshLevel.begin(self, ((pollutionLevel, ), _response, _ex, _sent, context))

        def end_setPollutionTreshLevel(self, _r):
            return _M_Home.AC.AirConditionerPurifier._op_setPollutionTreshLevel.end(self, _r)

        def getPollutionTreshLevel(self, context=None):
            return _M_Home.AC.AirConditionerPurifier._op_getPollutionTreshLevel.invoke(self, ((), context))

        def getPollutionTreshLevelAsync(self, context=None):
            return _M_Home.AC.AirConditionerPurifier._op_getPollutionTreshLevel.invokeAsync(self, ((), context))

        def begin_getPollutionTreshLevel(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.AC.AirConditionerPurifier._op_getPollutionTreshLevel.begin(self, ((), _response, _ex, _sent, context))

        def end_getPollutionTreshLevel(self, _r):
            return _M_Home.AC.AirConditionerPurifier._op_getPollutionTreshLevel.end(self, _r)

        def isPurifyingOn(self, context=None):
            return _M_Home.AC.AirConditionerPurifier._op_isPurifyingOn.invoke(self, ((), context))

        def isPurifyingOnAsync(self, context=None):
            return _M_Home.AC.AirConditionerPurifier._op_isPurifyingOn.invokeAsync(self, ((), context))

        def begin_isPurifyingOn(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.AC.AirConditionerPurifier._op_isPurifyingOn.begin(self, ((), _response, _ex, _sent, context))

        def end_isPurifyingOn(self, _r):
            return _M_Home.AC.AirConditionerPurifier._op_isPurifyingOn.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Home.AC.AirConditionerPurifierPrx.ice_checkedCast(proxy, '::Home::AC::AirConditionerPurifier', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Home.AC.AirConditionerPurifierPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Home::AC::AirConditionerPurifier'
    _M_Home.AC._t_AirConditionerPurifierPrx = IcePy.defineProxy('::Home::AC::AirConditionerPurifier', AirConditionerPurifierPrx)

    _M_Home.AC.AirConditionerPurifierPrx = AirConditionerPurifierPrx
    del AirConditionerPurifierPrx

    _M_Home.AC.AirConditionerPurifier = Ice.createTempClass()
    class AirConditionerPurifier(_M_Home.AC.AirConditioner):

        def ice_ids(self, current=None):
            return ('::Home::AC::AirConditioner', '::Home::AC::AirConditionerPurifier', '::Home::Device', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Home::AC::AirConditionerPurifier'

        @staticmethod
        def ice_staticId():
            return '::Home::AC::AirConditionerPurifier'

        def setPollutionTreshLevel(self, pollutionLevel, current=None):
            raise NotImplementedError("servant method 'setPollutionTreshLevel' not implemented")

        def getPollutionTreshLevel(self, current=None):
            raise NotImplementedError("servant method 'getPollutionTreshLevel' not implemented")

        def isPurifyingOn(self, current=None):
            raise NotImplementedError("servant method 'isPurifyingOn' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Home.AC._t_AirConditionerPurifierDisp)

        __repr__ = __str__

    _M_Home.AC._t_AirConditionerPurifierDisp = IcePy.defineClass('::Home::AC::AirConditionerPurifier', AirConditionerPurifier, (), None, (_M_Home.AC._t_AirConditionerDisp,))
    AirConditionerPurifier._ice_type = _M_Home.AC._t_AirConditionerPurifierDisp

    AirConditionerPurifier._op_setPollutionTreshLevel = IcePy.Operation('setPollutionTreshLevel', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Home.AC._t_PollutionLevel, False, 0),), (), None, ())
    AirConditionerPurifier._op_getPollutionTreshLevel = IcePy.Operation('getPollutionTreshLevel', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_Home.AC._t_PollutionLevel, False, 0), ())
    AirConditionerPurifier._op_isPurifyingOn = IcePy.Operation('isPurifyingOn', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_bool, False, 0), (_M_Home._t_SwitchedOffError,))

    _M_Home.AC.AirConditionerPurifier = AirConditionerPurifier
    del AirConditionerPurifier

# End of module Home.AC

__name__ = 'Home'

# Start of module Home.Kitchen
_M_Home.Kitchen = Ice.openModule('Home.Kitchen')
__name__ = 'Home.Kitchen'

_M_Home.Kitchen._t_Refrigerator = IcePy.defineValue('::Home::Kitchen::Refrigerator', Ice.Value, -1, (), False, True, None, ())

if 'RefrigeratorPrx' not in _M_Home.Kitchen.__dict__:
    _M_Home.Kitchen.RefrigeratorPrx = Ice.createTempClass()
    class RefrigeratorPrx(_M_Home.DevicePrx):

        def setFridgeTemperature(self, temperature, context=None):
            return _M_Home.Kitchen.Refrigerator._op_setFridgeTemperature.invoke(self, ((temperature, ), context))

        def setFridgeTemperatureAsync(self, temperature, context=None):
            return _M_Home.Kitchen.Refrigerator._op_setFridgeTemperature.invokeAsync(self, ((temperature, ), context))

        def begin_setFridgeTemperature(self, temperature, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Kitchen.Refrigerator._op_setFridgeTemperature.begin(self, ((temperature, ), _response, _ex, _sent, context))

        def end_setFridgeTemperature(self, _r):
            return _M_Home.Kitchen.Refrigerator._op_setFridgeTemperature.end(self, _r)

        def getFridgeTemperature(self, context=None):
            return _M_Home.Kitchen.Refrigerator._op_getFridgeTemperature.invoke(self, ((), context))

        def getFridgeTemperatureAsync(self, context=None):
            return _M_Home.Kitchen.Refrigerator._op_getFridgeTemperature.invokeAsync(self, ((), context))

        def begin_getFridgeTemperature(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Kitchen.Refrigerator._op_getFridgeTemperature.begin(self, ((), _response, _ex, _sent, context))

        def end_getFridgeTemperature(self, _r):
            return _M_Home.Kitchen.Refrigerator._op_getFridgeTemperature.end(self, _r)

        def setTempUnit(self, unit, context=None):
            return _M_Home.Kitchen.Refrigerator._op_setTempUnit.invoke(self, ((unit, ), context))

        def setTempUnitAsync(self, unit, context=None):
            return _M_Home.Kitchen.Refrigerator._op_setTempUnit.invokeAsync(self, ((unit, ), context))

        def begin_setTempUnit(self, unit, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Kitchen.Refrigerator._op_setTempUnit.begin(self, ((unit, ), _response, _ex, _sent, context))

        def end_setTempUnit(self, _r):
            return _M_Home.Kitchen.Refrigerator._op_setTempUnit.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Home.Kitchen.RefrigeratorPrx.ice_checkedCast(proxy, '::Home::Kitchen::Refrigerator', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Home.Kitchen.RefrigeratorPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Home::Kitchen::Refrigerator'
    _M_Home.Kitchen._t_RefrigeratorPrx = IcePy.defineProxy('::Home::Kitchen::Refrigerator', RefrigeratorPrx)

    _M_Home.Kitchen.RefrigeratorPrx = RefrigeratorPrx
    del RefrigeratorPrx

    _M_Home.Kitchen.Refrigerator = Ice.createTempClass()
    class Refrigerator(_M_Home.Device):

        def ice_ids(self, current=None):
            return ('::Home::Device', '::Home::Kitchen::Refrigerator', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Home::Kitchen::Refrigerator'

        @staticmethod
        def ice_staticId():
            return '::Home::Kitchen::Refrigerator'

        def setFridgeTemperature(self, temperature, current=None):
            raise NotImplementedError("servant method 'setFridgeTemperature' not implemented")

        def getFridgeTemperature(self, current=None):
            raise NotImplementedError("servant method 'getFridgeTemperature' not implemented")

        def setTempUnit(self, unit, current=None):
            raise NotImplementedError("servant method 'setTempUnit' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Home.Kitchen._t_RefrigeratorDisp)

        __repr__ = __str__

    _M_Home.Kitchen._t_RefrigeratorDisp = IcePy.defineClass('::Home::Kitchen::Refrigerator', Refrigerator, (), None, (_M_Home._t_DeviceDisp,))
    Refrigerator._ice_type = _M_Home.Kitchen._t_RefrigeratorDisp

    Refrigerator._op_setFridgeTemperature = IcePy.Operation('setFridgeTemperature', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Home._t_Temperature, False, 0),), (), None, (_M_Home._t_TemperatureRangeError,))
    Refrigerator._op_getFridgeTemperature = IcePy.Operation('getFridgeTemperature', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_Home._t_Temperature, False, 0), (_M_Home._t_SwitchedOffError,))
    Refrigerator._op_setTempUnit = IcePy.Operation('setTempUnit', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Home._t_TempUnit, False, 0),), (), None, ())

    _M_Home.Kitchen.Refrigerator = Refrigerator
    del Refrigerator

_M_Home.Kitchen._t_RefrigeratorWithFreezer = IcePy.defineValue('::Home::Kitchen::RefrigeratorWithFreezer', Ice.Value, -1, (), False, True, None, ())

if 'RefrigeratorWithFreezerPrx' not in _M_Home.Kitchen.__dict__:
    _M_Home.Kitchen.RefrigeratorWithFreezerPrx = Ice.createTempClass()
    class RefrigeratorWithFreezerPrx(_M_Home.Kitchen.RefrigeratorPrx):

        def setFreezerTemperature(self, temperature, context=None):
            return _M_Home.Kitchen.RefrigeratorWithFreezer._op_setFreezerTemperature.invoke(self, ((temperature, ), context))

        def setFreezerTemperatureAsync(self, temperature, context=None):
            return _M_Home.Kitchen.RefrigeratorWithFreezer._op_setFreezerTemperature.invokeAsync(self, ((temperature, ), context))

        def begin_setFreezerTemperature(self, temperature, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Kitchen.RefrigeratorWithFreezer._op_setFreezerTemperature.begin(self, ((temperature, ), _response, _ex, _sent, context))

        def end_setFreezerTemperature(self, _r):
            return _M_Home.Kitchen.RefrigeratorWithFreezer._op_setFreezerTemperature.end(self, _r)

        def getFreezerTemperature(self, context=None):
            return _M_Home.Kitchen.RefrigeratorWithFreezer._op_getFreezerTemperature.invoke(self, ((), context))

        def getFreezerTemperatureAsync(self, context=None):
            return _M_Home.Kitchen.RefrigeratorWithFreezer._op_getFreezerTemperature.invokeAsync(self, ((), context))

        def begin_getFreezerTemperature(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Kitchen.RefrigeratorWithFreezer._op_getFreezerTemperature.begin(self, ((), _response, _ex, _sent, context))

        def end_getFreezerTemperature(self, _r):
            return _M_Home.Kitchen.RefrigeratorWithFreezer._op_getFreezerTemperature.end(self, _r)

        def isTurboFreezingOn(self, context=None):
            return _M_Home.Kitchen.RefrigeratorWithFreezer._op_isTurboFreezingOn.invoke(self, ((), context))

        def isTurboFreezingOnAsync(self, context=None):
            return _M_Home.Kitchen.RefrigeratorWithFreezer._op_isTurboFreezingOn.invokeAsync(self, ((), context))

        def begin_isTurboFreezingOn(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Kitchen.RefrigeratorWithFreezer._op_isTurboFreezingOn.begin(self, ((), _response, _ex, _sent, context))

        def end_isTurboFreezingOn(self, _r):
            return _M_Home.Kitchen.RefrigeratorWithFreezer._op_isTurboFreezingOn.end(self, _r)

        def setTurboFreezing(self, turboFreezing, context=None):
            return _M_Home.Kitchen.RefrigeratorWithFreezer._op_setTurboFreezing.invoke(self, ((turboFreezing, ), context))

        def setTurboFreezingAsync(self, turboFreezing, context=None):
            return _M_Home.Kitchen.RefrigeratorWithFreezer._op_setTurboFreezing.invokeAsync(self, ((turboFreezing, ), context))

        def begin_setTurboFreezing(self, turboFreezing, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Kitchen.RefrigeratorWithFreezer._op_setTurboFreezing.begin(self, ((turboFreezing, ), _response, _ex, _sent, context))

        def end_setTurboFreezing(self, _r):
            return _M_Home.Kitchen.RefrigeratorWithFreezer._op_setTurboFreezing.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Home.Kitchen.RefrigeratorWithFreezerPrx.ice_checkedCast(proxy, '::Home::Kitchen::RefrigeratorWithFreezer', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Home.Kitchen.RefrigeratorWithFreezerPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Home::Kitchen::RefrigeratorWithFreezer'
    _M_Home.Kitchen._t_RefrigeratorWithFreezerPrx = IcePy.defineProxy('::Home::Kitchen::RefrigeratorWithFreezer', RefrigeratorWithFreezerPrx)

    _M_Home.Kitchen.RefrigeratorWithFreezerPrx = RefrigeratorWithFreezerPrx
    del RefrigeratorWithFreezerPrx

    _M_Home.Kitchen.RefrigeratorWithFreezer = Ice.createTempClass()
    class RefrigeratorWithFreezer(_M_Home.Kitchen.Refrigerator):

        def ice_ids(self, current=None):
            return ('::Home::Device', '::Home::Kitchen::Refrigerator', '::Home::Kitchen::RefrigeratorWithFreezer', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Home::Kitchen::RefrigeratorWithFreezer'

        @staticmethod
        def ice_staticId():
            return '::Home::Kitchen::RefrigeratorWithFreezer'

        def setFreezerTemperature(self, temperature, current=None):
            raise NotImplementedError("servant method 'setFreezerTemperature' not implemented")

        def getFreezerTemperature(self, current=None):
            raise NotImplementedError("servant method 'getFreezerTemperature' not implemented")

        def isTurboFreezingOn(self, current=None):
            raise NotImplementedError("servant method 'isTurboFreezingOn' not implemented")

        def setTurboFreezing(self, turboFreezing, current=None):
            raise NotImplementedError("servant method 'setTurboFreezing' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Home.Kitchen._t_RefrigeratorWithFreezerDisp)

        __repr__ = __str__

    _M_Home.Kitchen._t_RefrigeratorWithFreezerDisp = IcePy.defineClass('::Home::Kitchen::RefrigeratorWithFreezer', RefrigeratorWithFreezer, (), None, (_M_Home.Kitchen._t_RefrigeratorDisp,))
    RefrigeratorWithFreezer._ice_type = _M_Home.Kitchen._t_RefrigeratorWithFreezerDisp

    RefrigeratorWithFreezer._op_setFreezerTemperature = IcePy.Operation('setFreezerTemperature', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Home._t_Temperature, False, 0),), (), None, (_M_Home._t_SwitchedOffError, _M_Home._t_TemperatureRangeError))
    RefrigeratorWithFreezer._op_getFreezerTemperature = IcePy.Operation('getFreezerTemperature', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_Home._t_Temperature, False, 0), (_M_Home._t_SwitchedOffError,))
    RefrigeratorWithFreezer._op_isTurboFreezingOn = IcePy.Operation('isTurboFreezingOn', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_bool, False, 0), (_M_Home._t_SwitchedOffError,))
    RefrigeratorWithFreezer._op_setTurboFreezing = IcePy.Operation('setTurboFreezing', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_bool, False, 0),), (), None, (_M_Home._t_SwitchedOffError,))

    _M_Home.Kitchen.RefrigeratorWithFreezer = RefrigeratorWithFreezer
    del RefrigeratorWithFreezer

if 'FrequencyRangeError' not in _M_Home.Kitchen.__dict__:
    _M_Home.Kitchen.FrequencyRangeError = Ice.createTempClass()
    class FrequencyRangeError(_M_Home.ErrorBase):
        def __init__(self, reason='', minFreq=0.0, maxFreq=0.0):
            _M_Home.ErrorBase.__init__(self, reason)
            self.minFreq = minFreq
            self.maxFreq = maxFreq

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Home::Kitchen::FrequencyRangeError'

    _M_Home.Kitchen._t_FrequencyRangeError = IcePy.defineException('::Home::Kitchen::FrequencyRangeError', FrequencyRangeError, (), False, _M_Home._t_ErrorBase, (
        ('minFreq', (), IcePy._t_double, False, 0),
        ('maxFreq', (), IcePy._t_double, False, 0)
    ))
    FrequencyRangeError._ice_type = _M_Home.Kitchen._t_FrequencyRangeError

    _M_Home.Kitchen.FrequencyRangeError = FrequencyRangeError
    del FrequencyRangeError

if 'VolumeRangeError' not in _M_Home.Kitchen.__dict__:
    _M_Home.Kitchen.VolumeRangeError = Ice.createTempClass()
    class VolumeRangeError(_M_Home.ErrorBase):
        def __init__(self, reason='', minVolumeLevel=0, maxVolumeLevel=0):
            _M_Home.ErrorBase.__init__(self, reason)
            self.minVolumeLevel = minVolumeLevel
            self.maxVolumeLevel = maxVolumeLevel

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Home::Kitchen::VolumeRangeError'

    _M_Home.Kitchen._t_VolumeRangeError = IcePy.defineException('::Home::Kitchen::VolumeRangeError', VolumeRangeError, (), False, _M_Home._t_ErrorBase, (
        ('minVolumeLevel', (), IcePy._t_short, False, 0),
        ('maxVolumeLevel', (), IcePy._t_short, False, 0)
    ))
    VolumeRangeError._ice_type = _M_Home.Kitchen._t_VolumeRangeError

    _M_Home.Kitchen.VolumeRangeError = VolumeRangeError
    del VolumeRangeError

_M_Home.Kitchen._t_RefrigeratorWithRadio = IcePy.defineValue('::Home::Kitchen::RefrigeratorWithRadio', Ice.Value, -1, (), False, True, None, ())

if 'RefrigeratorWithRadioPrx' not in _M_Home.Kitchen.__dict__:
    _M_Home.Kitchen.RefrigeratorWithRadioPrx = Ice.createTempClass()
    class RefrigeratorWithRadioPrx(_M_Home.Kitchen.RefrigeratorPrx):

        def setFrequency(self, freq, context=None):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_setFrequency.invoke(self, ((freq, ), context))

        def setFrequencyAsync(self, freq, context=None):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_setFrequency.invokeAsync(self, ((freq, ), context))

        def begin_setFrequency(self, freq, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_setFrequency.begin(self, ((freq, ), _response, _ex, _sent, context))

        def end_setFrequency(self, _r):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_setFrequency.end(self, _r)

        def getFrequency(self, context=None):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_getFrequency.invoke(self, ((), context))

        def getFrequencyAsync(self, context=None):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_getFrequency.invokeAsync(self, ((), context))

        def begin_getFrequency(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_getFrequency.begin(self, ((), _response, _ex, _sent, context))

        def end_getFrequency(self, _r):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_getFrequency.end(self, _r)

        def getRadioPowerState(self, context=None):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_getRadioPowerState.invoke(self, ((), context))

        def getRadioPowerStateAsync(self, context=None):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_getRadioPowerState.invokeAsync(self, ((), context))

        def begin_getRadioPowerState(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_getRadioPowerState.begin(self, ((), _response, _ex, _sent, context))

        def end_getRadioPowerState(self, _r):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_getRadioPowerState.end(self, _r)

        def setRadioPowerState(self, powerState, context=None):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_setRadioPowerState.invoke(self, ((powerState, ), context))

        def setRadioPowerStateAsync(self, powerState, context=None):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_setRadioPowerState.invokeAsync(self, ((powerState, ), context))

        def begin_setRadioPowerState(self, powerState, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_setRadioPowerState.begin(self, ((powerState, ), _response, _ex, _sent, context))

        def end_setRadioPowerState(self, _r):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_setRadioPowerState.end(self, _r)

        def setVolumeLevel(self, level, context=None):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_setVolumeLevel.invoke(self, ((level, ), context))

        def setVolumeLevelAsync(self, level, context=None):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_setVolumeLevel.invokeAsync(self, ((level, ), context))

        def begin_setVolumeLevel(self, level, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_setVolumeLevel.begin(self, ((level, ), _response, _ex, _sent, context))

        def end_setVolumeLevel(self, _r):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_setVolumeLevel.end(self, _r)

        def getVolumeLevel(self, context=None):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_getVolumeLevel.invoke(self, ((), context))

        def getVolumeLevelAsync(self, context=None):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_getVolumeLevel.invokeAsync(self, ((), context))

        def begin_getVolumeLevel(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_getVolumeLevel.begin(self, ((), _response, _ex, _sent, context))

        def end_getVolumeLevel(self, _r):
            return _M_Home.Kitchen.RefrigeratorWithRadio._op_getVolumeLevel.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Home.Kitchen.RefrigeratorWithRadioPrx.ice_checkedCast(proxy, '::Home::Kitchen::RefrigeratorWithRadio', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Home.Kitchen.RefrigeratorWithRadioPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Home::Kitchen::RefrigeratorWithRadio'
    _M_Home.Kitchen._t_RefrigeratorWithRadioPrx = IcePy.defineProxy('::Home::Kitchen::RefrigeratorWithRadio', RefrigeratorWithRadioPrx)

    _M_Home.Kitchen.RefrigeratorWithRadioPrx = RefrigeratorWithRadioPrx
    del RefrigeratorWithRadioPrx

    _M_Home.Kitchen.RefrigeratorWithRadio = Ice.createTempClass()
    class RefrigeratorWithRadio(_M_Home.Kitchen.Refrigerator):

        def ice_ids(self, current=None):
            return ('::Home::Device', '::Home::Kitchen::Refrigerator', '::Home::Kitchen::RefrigeratorWithRadio', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Home::Kitchen::RefrigeratorWithRadio'

        @staticmethod
        def ice_staticId():
            return '::Home::Kitchen::RefrigeratorWithRadio'

        def setFrequency(self, freq, current=None):
            raise NotImplementedError("servant method 'setFrequency' not implemented")

        def getFrequency(self, current=None):
            raise NotImplementedError("servant method 'getFrequency' not implemented")

        def getRadioPowerState(self, current=None):
            raise NotImplementedError("servant method 'getRadioPowerState' not implemented")

        def setRadioPowerState(self, powerState, current=None):
            raise NotImplementedError("servant method 'setRadioPowerState' not implemented")

        def setVolumeLevel(self, level, current=None):
            raise NotImplementedError("servant method 'setVolumeLevel' not implemented")

        def getVolumeLevel(self, current=None):
            raise NotImplementedError("servant method 'getVolumeLevel' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Home.Kitchen._t_RefrigeratorWithRadioDisp)

        __repr__ = __str__

    _M_Home.Kitchen._t_RefrigeratorWithRadioDisp = IcePy.defineClass('::Home::Kitchen::RefrigeratorWithRadio', RefrigeratorWithRadio, (), None, (_M_Home.Kitchen._t_RefrigeratorDisp,))
    RefrigeratorWithRadio._ice_type = _M_Home.Kitchen._t_RefrigeratorWithRadioDisp

    RefrigeratorWithRadio._op_setFrequency = IcePy.Operation('setFrequency', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_double, False, 0),), (), None, (_M_Home.Kitchen._t_FrequencyRangeError,))
    RefrigeratorWithRadio._op_getFrequency = IcePy.Operation('getFrequency', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_double, False, 0), ())
    RefrigeratorWithRadio._op_getRadioPowerState = IcePy.Operation('getRadioPowerState', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_Home._t_PowerState, False, 0), ())
    RefrigeratorWithRadio._op_setRadioPowerState = IcePy.Operation('setRadioPowerState', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Home._t_PowerState, False, 0),), (), None, ())
    RefrigeratorWithRadio._op_setVolumeLevel = IcePy.Operation('setVolumeLevel', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_short, False, 0),), (), None, (_M_Home.Kitchen._t_VolumeRangeError,))
    RefrigeratorWithRadio._op_getVolumeLevel = IcePy.Operation('getVolumeLevel', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_short, False, 0), ())

    _M_Home.Kitchen.RefrigeratorWithRadio = RefrigeratorWithRadio
    del RefrigeratorWithRadio

if 'BakingSide' not in _M_Home.Kitchen.__dict__:
    _M_Home.Kitchen.BakingSide = Ice.createTempClass()
    class BakingSide(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    BakingSide.UP = BakingSide("UP", 0)
    BakingSide.DOWN = BakingSide("DOWN", 1)
    BakingSide.BOTH = BakingSide("BOTH", 2)
    BakingSide._enumerators = { 0:BakingSide.UP, 1:BakingSide.DOWN, 2:BakingSide.BOTH }

    _M_Home.Kitchen._t_BakingSide = IcePy.defineEnum('::Home::Kitchen::BakingSide', BakingSide, (), BakingSide._enumerators)

    _M_Home.Kitchen.BakingSide = BakingSide
    del BakingSide

if 'BakingParams' not in _M_Home.Kitchen.__dict__:
    _M_Home.Kitchen.BakingParams = Ice.createTempClass()
    class BakingParams(object):
        def __init__(self, side=_M_Home.Kitchen.BakingSide.UP, temperature=Ice._struct_marker, durationMins=0):
            self.side = side
            if temperature is Ice._struct_marker:
                self.temperature = _M_Home.Temperature()
            else:
                self.temperature = temperature
            self.durationMins = durationMins

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_Home.Kitchen.BakingParams):
                return NotImplemented
            else:
                if self.side != other.side:
                    return False
                if self.temperature != other.temperature:
                    return False
                if self.durationMins != other.durationMins:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_Home.Kitchen._t_BakingParams)

        __repr__ = __str__

    _M_Home.Kitchen._t_BakingParams = IcePy.defineStruct('::Home::Kitchen::BakingParams', BakingParams, (), (
        ('side', (), _M_Home.Kitchen._t_BakingSide),
        ('temperature', (), _M_Home._t_Temperature),
        ('durationMins', (), IcePy._t_int)
    ))

    _M_Home.Kitchen.BakingParams = BakingParams
    del BakingParams

_M_Home.Kitchen._t_Oven = IcePy.defineValue('::Home::Kitchen::Oven', Ice.Value, -1, (), False, True, None, ())

if 'OvenPrx' not in _M_Home.Kitchen.__dict__:
    _M_Home.Kitchen.OvenPrx = Ice.createTempClass()
    class OvenPrx(_M_Home.DevicePrx):

        def startBaking(self, bakingParams, context=None):
            return _M_Home.Kitchen.Oven._op_startBaking.invoke(self, ((bakingParams, ), context))

        def startBakingAsync(self, bakingParams, context=None):
            return _M_Home.Kitchen.Oven._op_startBaking.invokeAsync(self, ((bakingParams, ), context))

        def begin_startBaking(self, bakingParams, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Kitchen.Oven._op_startBaking.begin(self, ((bakingParams, ), _response, _ex, _sent, context))

        def end_startBaking(self, _r):
            return _M_Home.Kitchen.Oven._op_startBaking.end(self, _r)

        def isBakingNow(self, context=None):
            return _M_Home.Kitchen.Oven._op_isBakingNow.invoke(self, ((), context))

        def isBakingNowAsync(self, context=None):
            return _M_Home.Kitchen.Oven._op_isBakingNow.invokeAsync(self, ((), context))

        def begin_isBakingNow(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Kitchen.Oven._op_isBakingNow.begin(self, ((), _response, _ex, _sent, context))

        def end_isBakingNow(self, _r):
            return _M_Home.Kitchen.Oven._op_isBakingNow.end(self, _r)

        def getBakingParams(self, context=None):
            return _M_Home.Kitchen.Oven._op_getBakingParams.invoke(self, ((), context))

        def getBakingParamsAsync(self, context=None):
            return _M_Home.Kitchen.Oven._op_getBakingParams.invokeAsync(self, ((), context))

        def begin_getBakingParams(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Kitchen.Oven._op_getBakingParams.begin(self, ((), _response, _ex, _sent, context))

        def end_getBakingParams(self, _r):
            return _M_Home.Kitchen.Oven._op_getBakingParams.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Home.Kitchen.OvenPrx.ice_checkedCast(proxy, '::Home::Kitchen::Oven', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Home.Kitchen.OvenPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Home::Kitchen::Oven'
    _M_Home.Kitchen._t_OvenPrx = IcePy.defineProxy('::Home::Kitchen::Oven', OvenPrx)

    _M_Home.Kitchen.OvenPrx = OvenPrx
    del OvenPrx

    _M_Home.Kitchen.Oven = Ice.createTempClass()
    class Oven(_M_Home.Device):

        def ice_ids(self, current=None):
            return ('::Home::Device', '::Home::Kitchen::Oven', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Home::Kitchen::Oven'

        @staticmethod
        def ice_staticId():
            return '::Home::Kitchen::Oven'

        def startBaking(self, bakingParams, current=None):
            raise NotImplementedError("servant method 'startBaking' not implemented")

        def isBakingNow(self, current=None):
            raise NotImplementedError("servant method 'isBakingNow' not implemented")

        def getBakingParams(self, current=None):
            raise NotImplementedError("servant method 'getBakingParams' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Home.Kitchen._t_OvenDisp)

        __repr__ = __str__

    _M_Home.Kitchen._t_OvenDisp = IcePy.defineClass('::Home::Kitchen::Oven', Oven, (), None, (_M_Home._t_DeviceDisp,))
    Oven._ice_type = _M_Home.Kitchen._t_OvenDisp

    Oven._op_startBaking = IcePy.Operation('startBaking', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Home.Kitchen._t_BakingParams, False, 0),), (), None, (_M_Home._t_SwitchedOffError, _M_Home._t_TemperatureRangeError, _M_Home._t_DurationError))
    Oven._op_isBakingNow = IcePy.Operation('isBakingNow', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_bool, False, 0), (_M_Home._t_SwitchedOffError,))
    Oven._op_getBakingParams = IcePy.Operation('getBakingParams', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_Home.Kitchen._t_BakingParams, False, 0), (_M_Home._t_NotDefinedError, _M_Home._t_SwitchedOffError))

    _M_Home.Kitchen.Oven = Oven
    del Oven

# End of module Home.Kitchen

__name__ = 'Home'

# End of module Home
